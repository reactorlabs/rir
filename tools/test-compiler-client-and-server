#!/bin/bash -e

# region prelude
set -e
SCRIPTPATH=$(cd "$(dirname "$0")" && pwd)
if [ ! -d "$SCRIPTPATH" ]; then
    echo "Could not determine absolute dir of $0"
    echo "Maybe accessed with symlink"
fi
export SCRIPTPATH

if [ -z "$RIR_BUILD" ]; then
    RIR_BUILD=$(pwd)
fi
export RIR_BUILD
# shellcheck disable=SC2144
if [ ! -f $RIR_BUILD/librir.* ]; then
    echo "could not find librir. are you in the correct directory?"
    exit 1
fi

. "${SCRIPTPATH}/script_include.sh"
# endregion

export PORT="${PORT=5555}"

# From https://stackoverflow.com/questions/71776455/stop-bash-if-any-of-the-functions-fail-in-parallel
# We run both the compiler server and client, but exit early if either of them fails
# Boilerplate
LOCKDIR=$(mktemp -d) || exit "$?"
trap 'rm -rf "$LOCKDIR"; wait' EXIT
diex() {
  echo "!! $1 crashed" >&2;

  # kill the other process
  if [ "$1" == "server" ]; then
      [ ! -z "$client_pid" ] && kill "$client_pid"
  else
      [ ! -z "$server_pid" ] && kill "$server_pid"
  fi

  exit 1
}

# Actually run compiler server and client, we delay the client a bit to ensure the server is started
{ LOG_PREFIX="(server) " "${SCRIPTPATH}/test-compiler-server-only" || diex "server"; } &
server_pid=$!
{ sleep 0.1; LOG_PREFIX="(client) " "${SCRIPTPATH}/test-compiler-client-only" || diex "client"; } &
client_pid=$!

# Ensure the process keeps running until the children are actually done
wait
